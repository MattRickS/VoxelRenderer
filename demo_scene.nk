#! /usr/local/Nuke12.0v8/libnuke-12.0.8.so -nx
version 12.0 v8
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1976" y="188" w="2504" h="1376" maximized="1" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1841" stretch="1"/>
            <splitter orientation="2">
                <split size="782"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                </dock>
                <split size="550"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/VoxelRenderer/demo_scene.nk
 frame 182
 last_frame 360
 format "1920 1080 0 0 1920 1080 1 HD_1080"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Axis2 {
 inputs 0
 rotate {0 {frame} 0}
 pivot {0.75 0.5 0.5}
 name Axis1
 xpos -170
 ypos -263
 addUserKnob {20 "Ppos Locator"}
 addUserKnob {18 pointPosition l "Point Position"}
 pointPosition {0 0 0}
 addUserKnob {6 pointPosition_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
}
Camera2 {
 translate {0.75 0.5 5}
 frame_rate 25
 name Camera1
 label "\[basename \[value fbx_node_name ]]"
 xpos -170
 ypos -147
}
Constant {
 inputs 0
 color {0.104 0.322 0.62 0}
 color_panelDropped true
 name Constant1
 xpos -294
 ypos -477
}
Ramp {
 p0 {100 -176}
 p1 {100 1051}
 type smooth1
 color {0.01376097649 0.09777082503 0.3369482756 0}
 color_panelDropped true
 name Ramp1
 xpos -294
 ypos -405
}
set N5ff69b0 [stack 0]
Axis2 {
 inputs 0
 translate {0 8 0}
 name LIGHT
 xpos -167
 ypos -498
 addUserKnob {20 "Ppos Locator"}
 addUserKnob {18 pointPosition l "Point Position"}
 pointPosition {0 0 0}
 addUserKnob {6 pointPosition_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
}
Group {
 inputs 0
 name V_Grid
 tile_color 0xc44b11ff
 xpos -41
 ypos -1026
 addUserKnob {20 VGrid}
 addUserKnob {31 voxel_bbox l "Bounding Box"}
 voxel_bbox {0 0 0 1.7 1 1}
 addUserKnob {18 gridres l Resolution R 1 256}
 gridres 256
 addUserKnob {6 gridres_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 uniform -STARTLINE}
 uniform true
 addUserKnob {41 color l Color T Constant1.color}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_grid.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_grid.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_grid.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_grid.maxTileLines}
}
 Axis2 {
  inputs 0
  display off
  selectable false
  name vTransformMatrix
  xpos -22
  ypos 124
  addUserKnob {20 "Ppos Locator"}
  addUserKnob {18 pointPosition l "Point Position"}
  pointPosition {0 0 0}
  addUserKnob {6 pointPosition_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 }
 Constant {
  inputs 0
  color {0 0 0 0.5}
  name Constant1
  xpos 159
  ypos -138
 }
 Reformat {
  type "to box"
  box_width {{ceil(sqrt(CONTROL.total))}}
  box_height {{ceil(sqrt(CONTROL.total))}}
  box_fixed true
  resize fill
  center false
  name Reformat1
  xpos 159
  ypos -29
 }
set N603e120 [stack 0]
 Dot {
  name Dot2
  note_font_size 20
  xpos 85
  ypos -25
 }
 BlinkScript {
  kernelSourceFile bin/generate/grid.cpp
  KernelDescription "1 \"VGrid\" iterate pixelWise 3b140e8cbfda428ac95853bd9e9761e44d4c51aad2633cdb8042495cb9b9755b 2 \"format\" Read Point \"dst\" Write Point 4 \"bbox_min\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"bbox_max\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"resolution\" Int 3 AAAAAAAAAAAAAAAAAAAAAA== \"total\" Int 1 AAAAAA=="
  kernelSource "kernel VGrid : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead> format;\n  Image<eWrite> dst;\n\n  param:\n    float3 bbox_min; // from origin\n    float3 bbox_max; // from origin\n    int3 resolution;\n    int total;\n\n  local:\n    float3 scale;\n\n  void init()\n  \{\n    for (int c = 0; c < 3; c++)\n      scale\[c] = (bbox_max\[c] - bbox_min\[c]) / resolution\[c];\n  \}\n\n  void process(int2 pos)\n  \{\n    int id = pos.y * dst.bounds.width() + pos.x;\n    if (id >= total)\n    \{\n      dst() = 0;\n      return;\n    \}\n    int xy = id / resolution.z;\n    dst(0) = ((xy % resolution.x) + 0.5f) * scale.x + bbox_min.x;\n    dst(1) = ((xy / resolution.x) + 0.5f) * scale.y + bbox_min.y;\n    dst(2) = ((id % resolution.z) + 0.5f) * scale.z + bbox_min.z;\n    dst(3) = 1;\n  \}\n\};"
  rebuild ""
  VGrid_bbox_min {{parent.voxel_bbox.x} {parent.voxel_bbox.y} {parent.voxel_bbox.n}}
  VGrid_bbox_max {{parent.voxel_bbox.r} {parent.voxel_bbox.t} {parent.voxel_bbox.f}}
  VGrid_resolution {{CONTROL.resolution.x} {CONTROL.resolution.y} {CONTROL.resolution.z}}
  VGrid_total {{CONTROL.total}}
  rebuild_finalise ""
  name BlinkScript_grid
  xpos 51
  ypos 33
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 85
  ypos 103
 }
push $N603e120
add_layer {voxels voxels.x voxels.y voxels.z voxels.density}
 ShuffleCopy {
  inputs 2
  alpha alpha2
  black red
  white green
  red2 blue
  green2 alpha
  out2 voxels
  name ShuffleCopy1
  xpos 159
  ypos 99
 }
 ModifyMetaData {
  metadata {
   {set bbox "\[value voxel_bbox]"}
   {set resolution "\[value CONTROL.resolution]"}
   {set vTransformMatrix "\[value vTransformMatrix.world_matrix]"}
  }
  name ModifyMetaData1
  xpos 159
  ypos 143
 }
 Output {
  name Output
  xpos 159
  ypos 195
 }
 NoOp {
  inputs 0
  name CONTROL
  xpos 284
  ypos 39
  addUserKnob {20 User}
  addUserKnob {3 total}
  total {{"resolution.x * resolution.y * resolution.z"}}
  addUserKnob {7 res_scale}
  res_scale {{"gridres.r / (voxel_bbox.r - voxel_bbox.x)"}}
  addUserKnob {13 resolution}
  resolution {{"uniform ? rint(res_scale * (voxel_bbox.r - voxel_bbox.x)) : gridres"} {"uniform ? rint(res_scale * (voxel_bbox.t - voxel_bbox.y)) : gridres"} {"uniform ? rint(res_scale * (voxel_bbox.f - voxel_bbox.n)) : gridres"}}
 }
end_group
Dot {
 name Dot1
 label "GENERATE GRID"
 note_font_size 20
 xpos -7
 ypos -992
}
Dot {
 name Dot2
 note_font_size 20
 xpos -7
 ypos -949
}
set N74132b0 [stack 0]
Group {
 name V_Noise
 tile_color 0xc17939ff
 xpos -41
 ypos -921
 addUserKnob {20 VFNoise}
 addUserKnob {7 offset l Offset t "Expands or shrinks the noise" R -1 1}
 offset -0.295
 addUserKnob {7 density l Density R 0 100}
 density 1
 addUserKnob {26 ""}
 addUserKnob {3 seed l Seed}
 seed 512
 addUserKnob {7 size l Size R 0 100}
 size 0.5
 addUserKnob {3 octaves l Octaves}
 octaves 5
 addUserKnob {7 lacunarity l Lacunarity R 0 2}
 lacunarity 1.95
 addUserKnob {7 persistence l Persistence}
 persistence 0.645
 addUserKnob {26 ""}
 addUserKnob {41 operation T ChannelMerge1.operation}
 addUserKnob {41 mix T ChannelMerge1.mix}
 addUserKnob {20 transform l Transform}
 addUserKnob {41 translate T NOISE_TRANSFORM.translate}
 addUserKnob {41 rotate T NOISE_TRANSFORM.rotate}
 addUserKnob {41 scaling l scale T NOISE_TRANSFORM.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T NOISE_TRANSFORM.uniform_scale}
 addUserKnob {41 skew T NOISE_TRANSFORM.skew}
 addUserKnob {41 pivot T NOISE_TRANSFORM.pivot}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_noise.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_noise.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_noise.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_noise.maxTileLines}
}
 Axis2 {
  inputs 0
  scaling {1.7 0.8 1}
  pivot {0.75 0.5 0.5}
  name NOISE_TRANSFORM
  xpos 397
  ypos -93
  addUserKnob {20 "Ppos Locator"}
  addUserKnob {18 pointPosition l "Point Position"}
  pointPosition {0 0 0}
  addUserKnob {6 pointPosition_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 }
 Input {
  inputs 0
  name Input
  xpos 519
  ypos -287
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 553
  ypos -231
 }
set N743d720 [stack 0]
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 519
  ypos -196
  postage_stamp true
 }
 BlinkScript {
  kernelSourceFile bin/transform/noise.cpp
  KernelDescription "1 \"VFNoise\" iterate pixelWise 1ef06e2feb9fa1e26cd67a5927f5113b61bc4529be4a0184eeac0df1f6aa3c87 2 \"voxels\" Read Point \"dst\" Write Point 6 \"seed\" Int 1 AAAAAA== \"Size\" Float 1 AADwQQ== \"Octaves\" Int 1 BAAAAA== \"Lacunarity\" Float 1 AAAAQA== \"Persistence\" Float 1 AAAAPw== \"M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom( int seed )\n\{\n  return abs( ( seed * rand_multiplier + rand_increment ) % rand_modulus );\n\}\n\n// ===== Interpolation Functions =====\n\nstatic float Smooth (const float &t)\n\{\n  // Fifth degree polynomial\n  return t * t * t * (t * (t * 6.0f - 15.0f) + 10.0f);\n\}\n\nstatic float Lerp (const float &a, const float &b, const float &t)\n\{\n  return (b - a) * clamp(t, 0.0f, 1.0f) + a;\n\}\n\n\n// ===== Noise Function =====\n\nstatic float Perlin3D(float3 point, float frequency)\n\{\n  const int hash\[512] = \{\n    151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,\n    140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,\n    247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,\n     57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,\n     74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,\n     60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,\n     65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,\n    200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,\n     52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,\n    207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,\n    119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,\n    129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,\n    218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,\n     81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,\n    184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,\n    222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180,\n\n    \n    151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,\n    140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,\n    247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,\n     57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,\n     74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,\n     60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,\n     65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,\n    200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,\n     52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,\n    207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,\n    119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,\n    129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,\n    218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,\n     81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,\n    184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,\n    222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180\n  \};\n\n  const float4 gradients3D\[16] = \{\n    float4( 1.0f,  1.0f,  0.0f, 0.0f),\n    float4(-1.0f,  1.0f,  0.0f, 0.0f),\n    float4( 1.0f, -1.0f,  0.0f, 0.0f),\n    float4(-1.0f, -1.0f,  0.0f, 0.0f),\n    float4( 1.0f,  0.0f,  1.0f, 0.0f),\n    float4(-1.0f,  0.0f,  1.0f, 0.0f),\n    float4( 1.0f,  0.0f, -1.0f, 0.0f),\n    float4(-1.0f,  0.0f, -1.0f, 0.0f),\n    float4( 0.0f,  1.0f,  1.0f, 0.0f),\n    float4( 0.0f, -1.0f,  1.0f, 0.0f),\n    float4( 0.0f,  1.0f, -1.0f, 0.0f),\n    float4( 0.0f, -1.0f, -1.0f, 0.0f),\n    float4( 1.0f,  1.0f,  0.0f, 0.0f),\n    float4(-1.0f,  1.0f,  0.0f, 0.0f),\n    float4( 0.0f, -1.0f,  1.0f, 0.0f),\n    float4( 0.0f, -1.0f, -1.0f, 0.0f)\n  \};\n\n  const int hashMask = 255;\n  const int gradientsMask3D = 15;\n\n  point *= frequency;\n  int ix0 = floor(point.x);\n  int iy0 = floor(point.y);\n  int iz0 = floor(point.z);\n  float tx0 = point.x - ix0;\n  float ty0 = point.y - iy0;\n  float tz0 = point.z - iz0;\n  float tx1 = tx0 - 1.0f;\n  float ty1 = ty0 - 1.0f;\n  float tz1 = tz0 - 1.0f;\n  ix0 &= hashMask;\n  iy0 &= hashMask;\n  iz0 &= hashMask;\n  int ix1 = ix0 + 1;\n  int iy1 = iy0 + 1;\n  int iz1 = iz0 + 1;\n\n  int h0 = hash\[ ix0 ];\n  int h1 = hash\[ ix1 ];\n  int h00 = hash\[ h0 + iy0 ];\n  int h10 = hash\[ h1 + iy0 ];\n  int h01 = hash\[ h0 + iy1 ];\n  int h11 = hash\[ h1 + iy1 ];\n\n  // float3 fails for some unknown reason. Add an empty fourth\n  float4 g000 = gradients3D\[ hash\[ h00 + iz0 ] & gradientsMask3D ];\n  float4 g100 = gradients3D\[ hash\[ h10 + iz0 ] & gradientsMask3D ];\n  float4 g010 = gradients3D\[ hash\[ h01 + iz0 ] & gradientsMask3D ];\n  float4 g110 = gradients3D\[ hash\[ h11 + iz0 ] & gradientsMask3D ];\n  float4 g001 = gradients3D\[ hash\[ h00 + iz1 ] & gradientsMask3D ];\n  float4 g101 = gradients3D\[ hash\[ h10 + iz1 ] & gradientsMask3D ];\n  float4 g011 = gradients3D\[ hash\[ h01 + iz1 ] & gradientsMask3D ];\n  float4 g111 = gradients3D\[ hash\[ h11 + iz1 ] & gradientsMask3D ];\n\n  float v000 = dot(g000, float4(tx0, ty0, tz0, 0.0f));\n  float v100 = dot(g100, float4(tx1, ty0, tz0, 0.0f));\n  float v010 = dot(g010, float4(tx0, ty1, tz0, 0.0f));\n  float v110 = dot(g110, float4(tx1, ty1, tz0, 0.0f));\n  float v001 = dot(g001, float4(tx0, ty0, tz1, 0.0f));\n  float v101 = dot(g101, float4(tx1, ty0, tz1, 0.0f));\n  float v011 = dot(g011, float4(tx0, ty1, tz1, 0.0f));\n  float v111 = dot(g111, float4(tx1, ty1, tz1, 0.0f));\n\n  float tx = Smooth(tx0);\n  float ty = Smooth(ty0);\n  float tz = Smooth(tz0);\n  return Lerp(\n    Lerp(Lerp(v000, v100, tx), Lerp(v010, v110, tx), ty),\n    Lerp(Lerp(v001, v101, tx), Lerp(v011, v111, tx), ty),\n    tz);// * 0.5f + 0.5f;\n\}\n\n\nstatic float Fractal(float3 point, float frequency, int octaves, float lacunarity, float persistence)\n\{\n  \n  float sum = 0;\n  sum = Perlin3D(point, frequency);\n  float amplitude = 1.0f;\n  float range = 1.0f;\n  for (int o = 1; o < octaves; o++) \{\n    frequency *= lacunarity;\n    amplitude *= persistence;\n    range += amplitude;\n    sum += Perlin3D(point, frequency) * amplitude;\n  \}\n  return sum / range;\n\}\n\n\nkernel VFNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead> voxels;\n  Image<eWrite> dst;\n\n  param:\n    int seed;\n    float size;\n    int octaves;\n    float lacunarity;\n    float persistence;\n    float4x4 M;\n\n  local:\n    float3 seed_offset;\n    float frequency;\n    float4x4 M_inv;\n\n  void define()\n  \{\n    defineParam(size, \"Size\", 30.0f);\n    defineParam(octaves, \"Octaves\", 4);\n    defineParam(lacunarity, \"Lacunarity\", 2.0f);\n    defineParam(persistence, \"Persistence\", 0.5f);\n  \}\n\n  void init()\n  \{\n    int random = seed;\n    for (int c = 0; c < 3; c++)\n    \{\n      random = lcgRandom(random);\n      seed_offset\[c] = (random / float(rand_modulus)) * 10000;\n    \}\n    frequency = 1.0f / size;\n    M_inv = M.invert();\n  \}\n\n\n  float3 multVectMatrix(float4 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n\n  void process()\n  \{\n    float4 voxel = voxels();\n    float3 point = multVectMatrix(voxel, M_inv);\n    voxel.w = Fractal(point + seed_offset, frequency, octaves, lacunarity, persistence);\n    dst() = voxel;\n  \}\n    \n\};"
  rebuild ""
  VFNoise_seed {{parent.seed}}
  VFNoise_Size {{parent.size}}
  VFNoise_Octaves {{parent.octaves}}
  VFNoise_Lacunarity {{parent.lacunarity}}
  VFNoise_Persistence {{parent.persistence}}
  group_VFNoise_M 1
  VFNoise_M {
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
    }
  rebuild_finalise ""
  name BlinkScript_noise
  selected true
  xpos 519
  ypos -80
 }
 Add {
  channels alpha
  value {{parent.offset}}
  name OFFSET
  xpos 519
  ypos -22
 }
 Multiply {
  channels alpha
  value {{parent.density}}
  name DENSITY
  xpos 519
  ypos 16
 }
 Dot {
  name Dot3
  note_font_size 20
  xpos 553
  ypos 82
 }
push $N743d720
 Dot {
  name Dot2
  note_font_size 20
  xpos 680
  ypos -231
 }
 ChannelMerge {
  inputs 2
  operation plus
  name ChannelMerge1
  xpos 646
  ypos 65
 }
 Output {
  name Output
  xpos 646
  ypos 145
 }
end_group
Group {
 name V_Shape
 knobChanged "\nif nuke.thisKnob().name() == \"shape\":\n    if nuke.thisKnob().getValue() < 3:\n        for knob in (\"xplane\", \"yplane\", \"zplane\"):\n            nuke.thisNode().knob(knob).setFlag(0x00040000)\n    else:\n        for knob in (\"xplane\", \"yplane\", \"zplane\"):\n            nuke.thisNode().knob(knob).clearFlag(0x00040000)\n"
 tile_color 0xc17939ff
 xpos -41
 ypos -895
 addUserKnob {20 VoxelTransform}
 addUserKnob {4 shape l Shape M {Sphere Cube Diamond Plane}}
 addUserKnob {6 xplane l x -STARTLINE +HIDDEN}
 addUserKnob {6 yplane l y -STARTLINE +HIDDEN}
 addUserKnob {6 zplane l z -STARTLINE +HIDDEN}
 addUserKnob {13 center l Center}
 center {0.65 0.5 0.5}
 addUserKnob {6 world_space l "World Space" -STARTLINE}
 world_space true
 addUserKnob {7 shapesize l Size R 0 10}
 shapesize 0.3
 addUserKnob {18 scale l Scale}
 scale {1.2 0.55 1}
 addUserKnob {6 scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 pdensity l "Positive Density" t "Multiplier for the positive density values" R 0 100}
 addUserKnob {7 ndensity l "Negative Density" t "Multiplier for the negative density values" R 0 100}
 ndensity 3
 addUserKnob {7 padd l "Positive Add" t "Increase the positive value" R 0 100}
 addUserKnob {7 nadd l "Negative Add" t "Increase the negative value" R 0 100}
 addUserKnob {26 ""}
 addUserKnob {41 operation T ChannelMerge1.operation}
 addUserKnob {41 mix T ChannelMerge1.mix}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_transform.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_transform.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_transform.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_transform.maxTileLines}
}
 Input {
  inputs 0
  name Input
  xpos 562
  ypos -108
 }
 Dot {
  name Dot9
  note_font_size 20
  xpos 596
  ypos -53
 }
set N74bf3d0 [stack 0]
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 562
  ypos -6
  postage_stamp true
 }
set N74c4050 [stack 0]
 Dot {
  name Dot11
  note_font_size 20
  xpos 706
  ypos 34
 }
 BlinkScript {
  kernelSourceFile bin/transform/transform.cpp
  KernelDescription "1 \"VTransform\" iterate pixelWise 5b690b92e4ac81d8c4109362853108ee2d03e941660f97309bcdff56941ad2cd 2 \"voxels\" Read Point \"dst\" Write Point 1 \"M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel VTransform : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead> voxels;\n  Image<eWrite> dst;\n\n  param:\n    float4x4 M;\n  \n  float4 multVectMatrix(float4 vec, float4x4 M)\n  \{\n    float4 out = float4(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3],\n      vec.w\n    );\n\n    return out;\n  \}\n\n  void process()\n  \{\n    float4 position = voxels();\n    dst() = multVectMatrix(position, M);\n  \} \n\};"
  rebuild ""
  group_VTransform_M 1
  VTransform_M {
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 3]"}}
    }
  rebuild_finalise ""
  name BlinkScript_transform
  selected true
  xpos 672
  ypos 84
 }
 Dot {
  name Dot12
  note_font_size 20
  xpos 706
  ypos 149
 }
push $N74c4050
 Switch {
  inputs 2
  which {{parent.world_space}}
  name Switch2
  xpos 562
  ypos 145
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 596
  ypos 246
 }
set N74fb570 [stack 0]
 Dot {
  name Dot4
  note_font_size 20
  xpos 701
  ypos 246
 }
set N7500470 [stack 0]
 Dot {
  name Dot6
  note_font_size 20
  xpos 811
  ypos 246
 }
 Expression {
  temp_name0 r_dist
  temp_expr0 "(r - center.x) * scale.r"
  temp_name1 g_dist
  temp_expr1 "(g - center.y) * scale.g"
  temp_name2 b_dist
  temp_expr2 "(b - center.z) * scale.b"
  temp_name3 dist
  temp_expr3 "r_dist * xplane + g_dist * yplane + b_dist * zplane"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  name PLANE
  xpos 777
  ypos 306
 }
 Dot {
  name Dot7
  note_font_size 20
  xpos 811
  ypos 441
 }
push $N7500470
 Expression {
  temp_name0 r_dist
  temp_expr0 "((shapesize*scale.r) / 3 - abs(r - center.x))/(shapesize*scale.r)"
  temp_name1 g_dist
  temp_expr1 "((shapesize*scale.g) / 3 - abs(g - center.y))/(shapesize*scale.g)"
  temp_name2 b_dist
  temp_expr2 "((shapesize*scale.b) / 3 - abs(b - center.z))/(shapesize*scale.b)"
  temp_name3 dist
  temp_expr3 "r_dist + g_dist + b_dist"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  name DIAMOND
  xpos 667
  ypos 306
 }
 Dot {
  name Dot5
  note_font_size 20
  xpos 701
  ypos 377
 }
push $N74fb570
 Expression {
  temp_name0 dx
  temp_expr0 "shapesize * scale.r - abs(r - center.x)"
  temp_name1 dy
  temp_expr1 "shapesize * scale.g - abs(g - center.y)"
  temp_name2 dz
  temp_expr2 "shapesize * scale.b - abs(b - center.z)"
  temp_name3 dist
  temp_expr3 "(min(min(dx, dy), dz))"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  channel3 none
  name CUBE
  xpos 562
  ypos 306
 }
push $N74fb570
 Dot {
  name Dot2
  note_font_size 20
  xpos 489
  ypos 246
 }
 Expression {
  temp_name0 dist
  temp_expr0 "(shapesize - sqrt(((r - center.x)**2)/scale.r + ((g - center.y)**2)/scale.g + ((b - center.z)**2)/scale.b))"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  channel3 none
  name SPHERE
  xpos 455
  ypos 306
 }
 Dot {
  name Dot3
  note_font_size 20
  xpos 489
  ypos 377
 }
 Switch {
  inputs 4
  which {{shape}}
  name Switch1
  xpos 562
  ypos 437
 }
push $N74bf3d0
 Dot {
  name Dot8
  note_font_size 20
  xpos 379
  ypos -53
 }
 Dot {
  name Dot10
  note_font_size 20
  xpos 379
  ypos 524
 }
 ChannelMerge {
  inputs 2
  operation plus
  mix 0.712
  name ChannelMerge1
  xpos 562
  ypos 507
 }
 Output {
  name Output
  xpos 562
  ypos 596
 }
end_group
Expression {
 channel0 alpha
 expr0 "a < 0 ? a * 0.7 : a"
 channel1 none
 channel2 none
 name Expression1
 xpos -41
 ypos -869
}
push $N74132b0
Dot {
 name Dot3
 note_font_size 20
 xpos 94
 ypos -949
}
Group {
 name V_Noise1
 tile_color 0xc17939ff
 xpos 60
 ypos -922
 addUserKnob {20 VFNoise}
 addUserKnob {7 offset l Offset t "Expands or shrinks the noise" R -1 1}
 addUserKnob {7 density l Density R 0 100}
 density 1
 addUserKnob {26 ""}
 addUserKnob {3 seed l Seed}
 seed 121
 addUserKnob {7 size l Size R 0 100}
 size 0.5
 addUserKnob {3 octaves l Octaves}
 octaves 5
 addUserKnob {7 lacunarity l Lacunarity R 0 2}
 lacunarity 1.95
 addUserKnob {7 persistence l Persistence}
 persistence 0.7
 addUserKnob {26 ""}
 addUserKnob {41 operation T ChannelMerge1.operation}
 addUserKnob {41 mix T ChannelMerge1.mix}
 addUserKnob {20 transform l Transform}
 addUserKnob {41 translate T NOISE_TRANSFORM.translate}
 addUserKnob {41 rotate T NOISE_TRANSFORM.rotate}
 addUserKnob {41 scaling l scale T NOISE_TRANSFORM.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T NOISE_TRANSFORM.uniform_scale}
 addUserKnob {41 skew T NOISE_TRANSFORM.skew}
 addUserKnob {41 pivot T NOISE_TRANSFORM.pivot}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_noise.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_noise.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_noise.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_noise.maxTileLines}
}
 Axis2 {
  inputs 0
  translate {0 -0.4 0}
  scaling {1.5 1 1}
  name NOISE_TRANSFORM
  xpos 397
  ypos -93
  addUserKnob {20 "Ppos Locator"}
  addUserKnob {18 pointPosition l "Point Position"}
  pointPosition {0 0 0}
  addUserKnob {6 pointPosition_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 }
 Input {
  inputs 0
  name Input
  xpos 519
  ypos -287
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 553
  ypos -231
 }
set N75b1c40 [stack 0]
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 519
  ypos -196
  postage_stamp true
 }
 BlinkScript {
  kernelSourceFile bin/transform/noise.cpp
  KernelDescription "1 \"VFNoise\" iterate pixelWise 1ef06e2feb9fa1e26cd67a5927f5113b61bc4529be4a0184eeac0df1f6aa3c87 2 \"voxels\" Read Point \"dst\" Write Point 6 \"seed\" Int 1 AAAAAA== \"Size\" Float 1 AADwQQ== \"Octaves\" Int 1 BAAAAA== \"Lacunarity\" Float 1 AAAAQA== \"Persistence\" Float 1 AAAAPw== \"M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom( int seed )\n\{\n  return abs( ( seed * rand_multiplier + rand_increment ) % rand_modulus );\n\}\n\n// ===== Interpolation Functions =====\n\nstatic float Smooth (const float &t)\n\{\n  // Fifth degree polynomial\n  return t * t * t * (t * (t * 6.0f - 15.0f) + 10.0f);\n\}\n\nstatic float Lerp (const float &a, const float &b, const float &t)\n\{\n  return (b - a) * clamp(t, 0.0f, 1.0f) + a;\n\}\n\n\n// ===== Noise Function =====\n\nstatic float Perlin3D(float3 point, float frequency)\n\{\n  const int hash\[512] = \{\n    151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,\n    140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,\n    247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,\n     57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,\n     74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,\n     60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,\n     65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,\n    200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,\n     52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,\n    207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,\n    119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,\n    129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,\n    218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,\n     81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,\n    184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,\n    222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180,\n\n    \n    151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,\n    140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,\n    247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,\n     57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,\n     74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,\n     60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,\n     65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,\n    200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,\n     52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,\n    207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,\n    119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,\n    129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,\n    218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,\n     81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,\n    184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,\n    222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180\n  \};\n\n  const float4 gradients3D\[16] = \{\n    float4( 1.0f,  1.0f,  0.0f, 0.0f),\n    float4(-1.0f,  1.0f,  0.0f, 0.0f),\n    float4( 1.0f, -1.0f,  0.0f, 0.0f),\n    float4(-1.0f, -1.0f,  0.0f, 0.0f),\n    float4( 1.0f,  0.0f,  1.0f, 0.0f),\n    float4(-1.0f,  0.0f,  1.0f, 0.0f),\n    float4( 1.0f,  0.0f, -1.0f, 0.0f),\n    float4(-1.0f,  0.0f, -1.0f, 0.0f),\n    float4( 0.0f,  1.0f,  1.0f, 0.0f),\n    float4( 0.0f, -1.0f,  1.0f, 0.0f),\n    float4( 0.0f,  1.0f, -1.0f, 0.0f),\n    float4( 0.0f, -1.0f, -1.0f, 0.0f),\n    float4( 1.0f,  1.0f,  0.0f, 0.0f),\n    float4(-1.0f,  1.0f,  0.0f, 0.0f),\n    float4( 0.0f, -1.0f,  1.0f, 0.0f),\n    float4( 0.0f, -1.0f, -1.0f, 0.0f)\n  \};\n\n  const int hashMask = 255;\n  const int gradientsMask3D = 15;\n\n  point *= frequency;\n  int ix0 = floor(point.x);\n  int iy0 = floor(point.y);\n  int iz0 = floor(point.z);\n  float tx0 = point.x - ix0;\n  float ty0 = point.y - iy0;\n  float tz0 = point.z - iz0;\n  float tx1 = tx0 - 1.0f;\n  float ty1 = ty0 - 1.0f;\n  float tz1 = tz0 - 1.0f;\n  ix0 &= hashMask;\n  iy0 &= hashMask;\n  iz0 &= hashMask;\n  int ix1 = ix0 + 1;\n  int iy1 = iy0 + 1;\n  int iz1 = iz0 + 1;\n\n  int h0 = hash\[ ix0 ];\n  int h1 = hash\[ ix1 ];\n  int h00 = hash\[ h0 + iy0 ];\n  int h10 = hash\[ h1 + iy0 ];\n  int h01 = hash\[ h0 + iy1 ];\n  int h11 = hash\[ h1 + iy1 ];\n\n  // float3 fails for some unknown reason. Add an empty fourth\n  float4 g000 = gradients3D\[ hash\[ h00 + iz0 ] & gradientsMask3D ];\n  float4 g100 = gradients3D\[ hash\[ h10 + iz0 ] & gradientsMask3D ];\n  float4 g010 = gradients3D\[ hash\[ h01 + iz0 ] & gradientsMask3D ];\n  float4 g110 = gradients3D\[ hash\[ h11 + iz0 ] & gradientsMask3D ];\n  float4 g001 = gradients3D\[ hash\[ h00 + iz1 ] & gradientsMask3D ];\n  float4 g101 = gradients3D\[ hash\[ h10 + iz1 ] & gradientsMask3D ];\n  float4 g011 = gradients3D\[ hash\[ h01 + iz1 ] & gradientsMask3D ];\n  float4 g111 = gradients3D\[ hash\[ h11 + iz1 ] & gradientsMask3D ];\n\n  float v000 = dot(g000, float4(tx0, ty0, tz0, 0.0f));\n  float v100 = dot(g100, float4(tx1, ty0, tz0, 0.0f));\n  float v010 = dot(g010, float4(tx0, ty1, tz0, 0.0f));\n  float v110 = dot(g110, float4(tx1, ty1, tz0, 0.0f));\n  float v001 = dot(g001, float4(tx0, ty0, tz1, 0.0f));\n  float v101 = dot(g101, float4(tx1, ty0, tz1, 0.0f));\n  float v011 = dot(g011, float4(tx0, ty1, tz1, 0.0f));\n  float v111 = dot(g111, float4(tx1, ty1, tz1, 0.0f));\n\n  float tx = Smooth(tx0);\n  float ty = Smooth(ty0);\n  float tz = Smooth(tz0);\n  return Lerp(\n    Lerp(Lerp(v000, v100, tx), Lerp(v010, v110, tx), ty),\n    Lerp(Lerp(v001, v101, tx), Lerp(v011, v111, tx), ty),\n    tz);// * 0.5f + 0.5f;\n\}\n\n\nstatic float Fractal(float3 point, float frequency, int octaves, float lacunarity, float persistence)\n\{\n  \n  float sum = 0;\n  sum = Perlin3D(point, frequency);\n  float amplitude = 1.0f;\n  float range = 1.0f;\n  for (int o = 1; o < octaves; o++) \{\n    frequency *= lacunarity;\n    amplitude *= persistence;\n    range += amplitude;\n    sum += Perlin3D(point, frequency) * amplitude;\n  \}\n  return sum / range;\n\}\n\n\nkernel VFNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead> voxels;\n  Image<eWrite> dst;\n\n  param:\n    int seed;\n    float size;\n    int octaves;\n    float lacunarity;\n    float persistence;\n    float4x4 M;\n\n  local:\n    float3 seed_offset;\n    float frequency;\n    float4x4 M_inv;\n\n  void define()\n  \{\n    defineParam(size, \"Size\", 30.0f);\n    defineParam(octaves, \"Octaves\", 4);\n    defineParam(lacunarity, \"Lacunarity\", 2.0f);\n    defineParam(persistence, \"Persistence\", 0.5f);\n  \}\n\n  void init()\n  \{\n    int random = seed;\n    for (int c = 0; c < 3; c++)\n    \{\n      random = lcgRandom(random);\n      seed_offset\[c] = (random / float(rand_modulus)) * 10000;\n    \}\n    frequency = 1.0f / size;\n    M_inv = M.invert();\n  \}\n\n\n  float3 multVectMatrix(float4 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n\n  void process()\n  \{\n    float4 voxel = voxels();\n    float3 point = multVectMatrix(voxel, M_inv);\n    voxel.w = Fractal(point + seed_offset, frequency, octaves, lacunarity, persistence);\n    dst() = voxel;\n  \}\n    \n\};"
  rebuild ""
  VFNoise_seed {{parent.seed}}
  VFNoise_Size {{parent.size}}
  VFNoise_Octaves {{parent.octaves}}
  VFNoise_Lacunarity {{parent.lacunarity}}
  VFNoise_Persistence {{parent.persistence}}
  group_VFNoise_M 1
  VFNoise_M {
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
    }
  rebuild_finalise ""
  name BlinkScript_noise
  selected true
  xpos 519
  ypos -80
 }
 Add {
  channels alpha
  value {{parent.offset}}
  name OFFSET
  xpos 519
  ypos -22
 }
 Multiply {
  channels alpha
  value {{parent.density}}
  name DENSITY
  xpos 519
  ypos 16
 }
 Dot {
  name Dot3
  note_font_size 20
  xpos 553
  ypos 82
 }
push $N75b1c40
 Dot {
  name Dot2
  note_font_size 20
  xpos 680
  ypos -231
 }
 ChannelMerge {
  inputs 2
  operation plus
  name ChannelMerge1
  xpos 646
  ypos 65
 }
 Output {
  name Output
  xpos 646
  ypos 145
 }
end_group
Group {
 name V_Shape1
 knobChanged "\nif nuke.thisKnob().name() == \"shape\":\n    if nuke.thisKnob().getValue() < 3:\n        for knob in (\"xplane\", \"yplane\", \"zplane\"):\n            nuke.thisNode().knob(knob).setFlag(0x00040000)\n    else:\n        for knob in (\"xplane\", \"yplane\", \"zplane\"):\n            nuke.thisNode().knob(knob).clearFlag(0x00040000)\n"
 tile_color 0xc17939ff
 xpos 60
 ypos -896
 addUserKnob {20 VoxelTransform}
 addUserKnob {4 shape l Shape M {Sphere Cube Diamond Plane}}
 addUserKnob {6 xplane l x -STARTLINE +HIDDEN}
 addUserKnob {6 yplane l y -STARTLINE +HIDDEN}
 addUserKnob {6 zplane l z -STARTLINE +HIDDEN}
 addUserKnob {13 center l Center}
 center {1 0.5 0.5}
 addUserKnob {6 world_space l "World Space" -STARTLINE}
 world_space true
 addUserKnob {7 shapesize l Size R 0 10}
 shapesize 0.3
 addUserKnob {18 scale l Scale}
 scale {1.2 0.55 0.5}
 addUserKnob {6 scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 pdensity l "Positive Density" t "Multiplier for the positive density values" R 0 100}
 addUserKnob {7 ndensity l "Negative Density" t "Multiplier for the negative density values" R 0 100}
 ndensity 3
 addUserKnob {7 padd l "Positive Add" t "Increase the positive value" R 0 100}
 addUserKnob {7 nadd l "Negative Add" t "Increase the negative value" R 0 100}
 addUserKnob {26 ""}
 addUserKnob {41 operation T ChannelMerge1.operation}
 addUserKnob {41 mix T ChannelMerge1.mix}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_transform.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_transform.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_transform.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_transform.maxTileLines}
}
 Input {
  inputs 0
  name Input
  xpos 562
  ypos -108
 }
 Dot {
  name Dot9
  note_font_size 20
  xpos 596
  ypos -53
 }
set N762b9b0 [stack 0]
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 562
  ypos -6
  postage_stamp true
 }
set N7630630 [stack 0]
 Dot {
  name Dot11
  note_font_size 20
  xpos 706
  ypos 34
 }
 BlinkScript {
  kernelSourceFile bin/transform/transform.cpp
  KernelDescription "1 \"VTransform\" iterate pixelWise 5b690b92e4ac81d8c4109362853108ee2d03e941660f97309bcdff56941ad2cd 2 \"voxels\" Read Point \"dst\" Write Point 1 \"M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel VTransform : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead> voxels;\n  Image<eWrite> dst;\n\n  param:\n    float4x4 M;\n  \n  float4 multVectMatrix(float4 vec, float4x4 M)\n  \{\n    float4 out = float4(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3],\n      vec.w\n    );\n\n    return out;\n  \}\n\n  void process()\n  \{\n    float4 position = voxels();\n    dst() = multVectMatrix(position, M);\n  \} \n\};"
  rebuild ""
  group_VTransform_M 1
  VTransform_M {
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 3]"}}
    }
  rebuild_finalise ""
  name BlinkScript_transform
  selected true
  xpos 672
  ypos 84
 }
 Dot {
  name Dot12
  note_font_size 20
  xpos 706
  ypos 149
 }
push $N7630630
 Switch {
  inputs 2
  which {{parent.world_space}}
  name Switch2
  xpos 562
  ypos 145
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 596
  ypos 246
 }
set N7667ab0 [stack 0]
 Dot {
  name Dot4
  note_font_size 20
  xpos 701
  ypos 246
 }
set N766c9b0 [stack 0]
 Dot {
  name Dot6
  note_font_size 20
  xpos 811
  ypos 246
 }
 Expression {
  temp_name0 r_dist
  temp_expr0 "(r - center.x) * scale.r"
  temp_name1 g_dist
  temp_expr1 "(g - center.y) * scale.g"
  temp_name2 b_dist
  temp_expr2 "(b - center.z) * scale.b"
  temp_name3 dist
  temp_expr3 "r_dist * xplane + g_dist * yplane + b_dist * zplane"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  name PLANE
  xpos 777
  ypos 306
 }
 Dot {
  name Dot7
  note_font_size 20
  xpos 811
  ypos 441
 }
push $N766c9b0
 Expression {
  temp_name0 r_dist
  temp_expr0 "((shapesize*scale.r) / 3 - abs(r - center.x))/(shapesize*scale.r)"
  temp_name1 g_dist
  temp_expr1 "((shapesize*scale.g) / 3 - abs(g - center.y))/(shapesize*scale.g)"
  temp_name2 b_dist
  temp_expr2 "((shapesize*scale.b) / 3 - abs(b - center.z))/(shapesize*scale.b)"
  temp_name3 dist
  temp_expr3 "r_dist + g_dist + b_dist"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  name DIAMOND
  xpos 667
  ypos 306
 }
 Dot {
  name Dot5
  note_font_size 20
  xpos 701
  ypos 377
 }
push $N7667ab0
 Expression {
  temp_name0 dx
  temp_expr0 "shapesize * scale.r - abs(r - center.x)"
  temp_name1 dy
  temp_expr1 "shapesize * scale.g - abs(g - center.y)"
  temp_name2 dz
  temp_expr2 "shapesize * scale.b - abs(b - center.z)"
  temp_name3 dist
  temp_expr3 "(min(min(dx, dy), dz))"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  channel3 none
  name CUBE
  xpos 562
  ypos 306
 }
push $N7667ab0
 Dot {
  name Dot2
  note_font_size 20
  xpos 489
  ypos 246
 }
 Expression {
  temp_name0 dist
  temp_expr0 "(shapesize - sqrt(((r - center.x)**2)/scale.r + ((g - center.y)**2)/scale.g + ((b - center.z)**2)/scale.b))"
  channel0 alpha
  expr0 "dist > 0 ? dist * pdensity + padd : dist * ndensity - nadd"
  channel1 none
  channel2 none
  channel3 none
  name SPHERE
  xpos 455
  ypos 306
 }
 Dot {
  name Dot3
  note_font_size 20
  xpos 489
  ypos 377
 }
 Switch {
  inputs 4
  which {{shape}}
  name Switch1
  xpos 562
  ypos 437
 }
push $N762b9b0
 Dot {
  name Dot8
  note_font_size 20
  xpos 379
  ypos -53
 }
 Dot {
  name Dot10
  note_font_size 20
  xpos 379
  ypos 524
 }
 ChannelMerge {
  inputs 2
  operation plus
  mix 0.712
  name ChannelMerge1
  xpos 562
  ypos 507
 }
 Output {
  name Output
  xpos 562
  ypos 596
 }
end_group
Expression {
 channel0 alpha
 expr0 "a < 0 ? a * 0.33 : a"
 channel1 none
 channel2 none
 name Expression2
 xpos 60
 ypos -870
}
Dot {
 name Dot4
 xpos 94
 ypos -826
}
ChannelMerge {
 inputs 2
 operation plus
 mix 0.155
 name ChannelMerge1
 xpos -41
 ypos -843
}
Expression {
 channel0 alpha
 expr0 "a == 0 ? -0.4 : a"
 channel1 none
 channel2 none
 name Expression3
 xpos -41
 ypos -791
}
Group {
 name V_Erode
 tile_color 0xc17939ff
 xpos -41
 ypos -765
 addUserKnob {20 VoxelErode}
 addUserKnob {7 size l Size R -5 5}
 size 3
 addUserKnob {41 mix T Copy1.mix}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_erode.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_erode.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_erode.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_erode.maxTileLines}
}
 Input {
  inputs 0
  name Input
  xpos 77
  ypos -218
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 111
  ypos -183
 }
set N77223b0 [stack 0]
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 77
  ypos -146
  postage_stamp true
 }
 BlinkScript {
  kernelSourceFile bin/transform/erode.cpp
  KernelDescription "1 \"VErode\" iterate pixelWise 2fe7d082f174f3fa5da2d0397253182277f21748b6bd04eb245b16ad49d83abf 2 \"voxels\" Read Random \"dst\" Write Point 4 \"bbox_min\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"bbox_max\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"resolution\" Int 3 AAAAAAAAAAAAAAAAAAAAAA== \"size\" Float 1 AAAAAA=="
  kernelSource "kernel VErode : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom> voxels;\n  Image<eWrite> dst;\n\n  param:\n    float3 bbox_min;\n    float3 bbox_max;\n    int3 resolution;\n    float size;\n\n  local:\n    float3 VoxelSizeInv;\n    bool negative;\n    int grid_width;\n    int range;\n    float max_length;\n\n  void init()\n  \{\n    for (int c = 0; c < 3; c++)\n      VoxelSizeInv\[c] = resolution\[c] / (bbox_max\[c] - bbox_min\[c]);\n    negative = size < 0;\n    grid_width = voxels.bounds.width();\n    range = negative ? floor(size) : ceil(size);\n    max_length = size * size;\n  \}\n\n  float voxelValue(int3 voxel)\n  \{\n    int id = (voxel.y * resolution.x + voxel.x) * resolution.z + voxel.z;\n    int x = id % grid_width;\n    int y = id / grid_width;\n    return voxels(x, y)\[3]; // Just alpha (density)\n  \}\n\n  void process(int2 pos)\n  \{\n    float4 current = voxels(pos.x, pos.y);\n    int3 voxel;\n    for (int c = 0; c < 3; c++)\n      voxel\[c] = int((current\[c] - bbox_min\[c]) * VoxelSizeInv\[c]);\n\n    float length, new_val = voxelValue(voxel);\n    if (negative)\n    \{\n      // Minimum value within specified range\n      for (int i = max(voxel.x + range, 0); i <= min(voxel.x - range, resolution.x - 1); i++)\n        for (int j = max(voxel.y + range, 0); j <= min(voxel.y - range, resolution.y - 1); j++)\n          for (int k = max(voxel.z + range, 0); k <= min(voxel.z - range, resolution.z - 1); k++)\n          \{\n            length = pow(i - voxel.x, 2) + pow(j - voxel.y, 2) + pow(k - voxel.z, 2);\n            new_val = min(new_val, voxelValue(int3(i, j, k)) + 10000.0f * (length > max_length));\n          \}\n    \}\n    else\n    \{\n      // Maximum value within specified range\n      for (int i = max(voxel.x - range, 0); i <= min(voxel.x + range, resolution.x - 1); i++)\n        for (int j = max(voxel.y - range, 0); j <= min(voxel.y + range, resolution.y - 1); j++)\n          for (int k = max(voxel.z - range, 0); k <= min(voxel.z + range, resolution.z - 1); k++)\n          \{\n            length = pow(i - voxel.x, 2) + pow(j - voxel.y, 2) + pow(k - voxel.z, 2);\n            new_val = max(new_val, voxelValue(int3(i, j, k)) - 10000.0f * (length > max_length));\n          \}\n    \}\n\n    dst() = current;\n    dst(3) = new_val;\n  \}\n\};"
  rebuild ""
  VErode_bbox_min {{"\[lindex \[metadata bbox] 0]"} {"\[lindex \[metadata bbox] 1]"} {"\[lindex \[metadata bbox] 2]"}}
  VErode_bbox_max {{"\[lindex \[metadata bbox] 3]"} {"\[lindex \[metadata bbox] 4]"} {"\[lindex \[metadata bbox] 5]"}}
  VErode_resolution {{"\[lindex \[metadata resolution] 0]"} {"\[lindex \[metadata resolution] 1]"} {"\[lindex \[metadata resolution] 2]"}}
  VErode_size {{parent.size}}
  rebuild_finalise ""
  name BlinkScript_erode
  xpos 77
  ypos -38
 }
 Dot {
  name Dot2
  note_font_size 20
  xpos 111
  ypos 28
 }
push $N77223b0
 Dot {
  name Dot3
  note_font_size 20
  xpos 213
  ypos -183
 }
 Copy {
  inputs 2
  from0 rgba.alpha
  to0 rgba.alpha
  mix 0.825
  name Copy1
  xpos 179
  ypos 18
 }
 Output {
  name Output
  xpos 179
  ypos 87
 }
end_group
Multiply {
 channels alpha
 value 20
 name Multiply1
 xpos -41
 ypos -739
}
Group {
 name V_Noise2
 tile_color 0xc17939ff
 xpos -41
 ypos -701
 addUserKnob {20 VFNoise}
 addUserKnob {7 offset l Offset t "Expands or shrinks the noise" R -1 1}
 offset -0.1
 addUserKnob {7 density l Density R 0 100}
 density 15
 addUserKnob {26 ""}
 addUserKnob {3 seed l Seed}
 seed 512
 addUserKnob {7 size l Size R 0 100}
 size 0.25
 addUserKnob {3 octaves l Octaves}
 octaves 5
 addUserKnob {7 lacunarity l Lacunarity R 0 2}
 lacunarity 1.95
 addUserKnob {7 persistence l Persistence}
 persistence 0.645
 addUserKnob {26 ""}
 addUserKnob {41 operation T ChannelMerge1.operation}
 addUserKnob {41 mix T ChannelMerge1.mix}
 addUserKnob {20 transform l Transform}
 addUserKnob {41 translate T NOISE_TRANSFORM.translate}
 addUserKnob {41 rotate T NOISE_TRANSFORM.rotate}
 addUserKnob {41 scaling l scale T NOISE_TRANSFORM.scaling}
 addUserKnob {41 uniform_scale l "uniform scale" T NOISE_TRANSFORM.uniform_scale}
 addUserKnob {41 skew T NOISE_TRANSFORM.skew}
 addUserKnob {41 pivot T NOISE_TRANSFORM.pivot}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_noise.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_noise.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_noise.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_noise.maxTileLines}
}
 Axis2 {
  inputs 0
  pivot {0.75 0.5 0.5}
  name NOISE_TRANSFORM
  xpos 397
  ypos -93
  addUserKnob {20 "Ppos Locator"}
  addUserKnob {18 pointPosition l "Point Position"}
  pointPosition {0 0 0}
  addUserKnob {6 pointPosition_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 }
 Input {
  inputs 0
  name Input
  xpos 519
  ypos -287
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 553
  ypos -231
 }
set N779eac0 [stack 0]
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 519
  ypos -196
  postage_stamp true
 }
 BlinkScript {
  kernelSourceFile bin/transform/noise.cpp
  KernelDescription "1 \"VFNoise\" iterate pixelWise 1ef06e2feb9fa1e26cd67a5927f5113b61bc4529be4a0184eeac0df1f6aa3c87 2 \"voxels\" Read Point \"dst\" Write Point 6 \"seed\" Int 1 AAAAAA== \"Size\" Float 1 AADwQQ== \"Octaves\" Int 1 BAAAAA== \"Lacunarity\" Float 1 AAAAQA== \"Persistence\" Float 1 AAAAPw== \"M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom( int seed )\n\{\n  return abs( ( seed * rand_multiplier + rand_increment ) % rand_modulus );\n\}\n\n// ===== Interpolation Functions =====\n\nstatic float Smooth (const float &t)\n\{\n  // Fifth degree polynomial\n  return t * t * t * (t * (t * 6.0f - 15.0f) + 10.0f);\n\}\n\nstatic float Lerp (const float &a, const float &b, const float &t)\n\{\n  return (b - a) * clamp(t, 0.0f, 1.0f) + a;\n\}\n\n\n// ===== Noise Function =====\n\nstatic float Perlin3D(float3 point, float frequency)\n\{\n  const int hash\[512] = \{\n    151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,\n    140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,\n    247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,\n     57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,\n     74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,\n     60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,\n     65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,\n    200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,\n     52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,\n    207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,\n    119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,\n    129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,\n    218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,\n     81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,\n    184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,\n    222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180,\n\n    \n    151,160,137, 91, 90, 15,131, 13,201, 95, 96, 53,194,233,  7,225,\n    140, 36,103, 30, 69,142,  8, 99, 37,240, 21, 10, 23,190,  6,148,\n    247,120,234, 75,  0, 26,197, 62, 94,252,219,203,117, 35, 11, 32,\n     57,177, 33, 88,237,149, 56, 87,174, 20,125,136,171,168, 68,175,\n     74,165, 71,134,139, 48, 27,166, 77,146,158,231, 83,111,229,122,\n     60,211,133,230,220,105, 92, 41, 55, 46,245, 40,244,102,143, 54,\n     65, 25, 63,161,  1,216, 80, 73,209, 76,132,187,208, 89, 18,169,\n    200,196,135,130,116,188,159, 86,164,100,109,198,173,186,  3, 64,\n     52,217,226,250,124,123,  5,202, 38,147,118,126,255, 82, 85,212,\n    207,206, 59,227, 47, 16, 58, 17,182,189, 28, 42,223,183,170,213,\n    119,248,152,  2, 44,154,163, 70,221,153,101,155,167, 43,172,  9,\n    129, 22, 39,253, 19, 98,108,110, 79,113,224,232,178,185,112,104,\n    218,246, 97,228,251, 34,242,193,238,210,144, 12,191,179,162,241,\n     81, 51,145,235,249, 14,239,107, 49,192,214, 31,181,199,106,157,\n    184, 84,204,176,115,121, 50, 45,127,  4,150,254,138,236,205, 93,\n    222,114, 67, 29, 24, 72,243,141,128,195, 78, 66,215, 61,156,180\n  \};\n\n  const float4 gradients3D\[16] = \{\n    float4( 1.0f,  1.0f,  0.0f, 0.0f),\n    float4(-1.0f,  1.0f,  0.0f, 0.0f),\n    float4( 1.0f, -1.0f,  0.0f, 0.0f),\n    float4(-1.0f, -1.0f,  0.0f, 0.0f),\n    float4( 1.0f,  0.0f,  1.0f, 0.0f),\n    float4(-1.0f,  0.0f,  1.0f, 0.0f),\n    float4( 1.0f,  0.0f, -1.0f, 0.0f),\n    float4(-1.0f,  0.0f, -1.0f, 0.0f),\n    float4( 0.0f,  1.0f,  1.0f, 0.0f),\n    float4( 0.0f, -1.0f,  1.0f, 0.0f),\n    float4( 0.0f,  1.0f, -1.0f, 0.0f),\n    float4( 0.0f, -1.0f, -1.0f, 0.0f),\n    float4( 1.0f,  1.0f,  0.0f, 0.0f),\n    float4(-1.0f,  1.0f,  0.0f, 0.0f),\n    float4( 0.0f, -1.0f,  1.0f, 0.0f),\n    float4( 0.0f, -1.0f, -1.0f, 0.0f)\n  \};\n\n  const int hashMask = 255;\n  const int gradientsMask3D = 15;\n\n  point *= frequency;\n  int ix0 = floor(point.x);\n  int iy0 = floor(point.y);\n  int iz0 = floor(point.z);\n  float tx0 = point.x - ix0;\n  float ty0 = point.y - iy0;\n  float tz0 = point.z - iz0;\n  float tx1 = tx0 - 1.0f;\n  float ty1 = ty0 - 1.0f;\n  float tz1 = tz0 - 1.0f;\n  ix0 &= hashMask;\n  iy0 &= hashMask;\n  iz0 &= hashMask;\n  int ix1 = ix0 + 1;\n  int iy1 = iy0 + 1;\n  int iz1 = iz0 + 1;\n\n  int h0 = hash\[ ix0 ];\n  int h1 = hash\[ ix1 ];\n  int h00 = hash\[ h0 + iy0 ];\n  int h10 = hash\[ h1 + iy0 ];\n  int h01 = hash\[ h0 + iy1 ];\n  int h11 = hash\[ h1 + iy1 ];\n\n  // float3 fails for some unknown reason. Add an empty fourth\n  float4 g000 = gradients3D\[ hash\[ h00 + iz0 ] & gradientsMask3D ];\n  float4 g100 = gradients3D\[ hash\[ h10 + iz0 ] & gradientsMask3D ];\n  float4 g010 = gradients3D\[ hash\[ h01 + iz0 ] & gradientsMask3D ];\n  float4 g110 = gradients3D\[ hash\[ h11 + iz0 ] & gradientsMask3D ];\n  float4 g001 = gradients3D\[ hash\[ h00 + iz1 ] & gradientsMask3D ];\n  float4 g101 = gradients3D\[ hash\[ h10 + iz1 ] & gradientsMask3D ];\n  float4 g011 = gradients3D\[ hash\[ h01 + iz1 ] & gradientsMask3D ];\n  float4 g111 = gradients3D\[ hash\[ h11 + iz1 ] & gradientsMask3D ];\n\n  float v000 = dot(g000, float4(tx0, ty0, tz0, 0.0f));\n  float v100 = dot(g100, float4(tx1, ty0, tz0, 0.0f));\n  float v010 = dot(g010, float4(tx0, ty1, tz0, 0.0f));\n  float v110 = dot(g110, float4(tx1, ty1, tz0, 0.0f));\n  float v001 = dot(g001, float4(tx0, ty0, tz1, 0.0f));\n  float v101 = dot(g101, float4(tx1, ty0, tz1, 0.0f));\n  float v011 = dot(g011, float4(tx0, ty1, tz1, 0.0f));\n  float v111 = dot(g111, float4(tx1, ty1, tz1, 0.0f));\n\n  float tx = Smooth(tx0);\n  float ty = Smooth(ty0);\n  float tz = Smooth(tz0);\n  return Lerp(\n    Lerp(Lerp(v000, v100, tx), Lerp(v010, v110, tx), ty),\n    Lerp(Lerp(v001, v101, tx), Lerp(v011, v111, tx), ty),\n    tz);// * 0.5f + 0.5f;\n\}\n\n\nstatic float Fractal(float3 point, float frequency, int octaves, float lacunarity, float persistence)\n\{\n  \n  float sum = 0;\n  sum = Perlin3D(point, frequency);\n  float amplitude = 1.0f;\n  float range = 1.0f;\n  for (int o = 1; o < octaves; o++) \{\n    frequency *= lacunarity;\n    amplitude *= persistence;\n    range += amplitude;\n    sum += Perlin3D(point, frequency) * amplitude;\n  \}\n  return sum / range;\n\}\n\n\nkernel VFNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead> voxels;\n  Image<eWrite> dst;\n\n  param:\n    int seed;\n    float size;\n    int octaves;\n    float lacunarity;\n    float persistence;\n    float4x4 M;\n\n  local:\n    float3 seed_offset;\n    float frequency;\n    float4x4 M_inv;\n\n  void define()\n  \{\n    defineParam(size, \"Size\", 30.0f);\n    defineParam(octaves, \"Octaves\", 4);\n    defineParam(lacunarity, \"Lacunarity\", 2.0f);\n    defineParam(persistence, \"Persistence\", 0.5f);\n  \}\n\n  void init()\n  \{\n    int random = seed;\n    for (int c = 0; c < 3; c++)\n    \{\n      random = lcgRandom(random);\n      seed_offset\[c] = (random / float(rand_modulus)) * 10000;\n    \}\n    frequency = 1.0f / size;\n    M_inv = M.invert();\n  \}\n\n\n  float3 multVectMatrix(float4 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n\n  void process()\n  \{\n    float4 voxel = voxels();\n    float3 point = multVectMatrix(voxel, M_inv);\n    voxel.w = Fractal(point + seed_offset, frequency, octaves, lacunarity, persistence);\n    dst() = voxel;\n  \}\n    \n\};"
  rebuild ""
  VFNoise_seed {{parent.seed}}
  VFNoise_Size {{parent.size}}
  VFNoise_Octaves {{parent.octaves}}
  VFNoise_Lacunarity {{parent.lacunarity}}
  VFNoise_Persistence {{parent.persistence}}
  group_VFNoise_M 1
  VFNoise_M {
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
      {{parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix} {parent.NOISE_TRANSFORM.world_matrix}}
    }
  rebuild_finalise ""
  name BlinkScript_noise
  selected true
  xpos 519
  ypos -80
 }
 Add {
  channels alpha
  value {{parent.offset}}
  name OFFSET
  xpos 519
  ypos -22
 }
 Multiply {
  channels alpha
  value {{parent.density}}
  name DENSITY
  xpos 519
  ypos 16
 }
 Dot {
  name Dot3
  note_font_size 20
  xpos 553
  ypos 82
 }
push $N779eac0
 Dot {
  name Dot2
  note_font_size 20
  xpos 680
  ypos -231
 }
 ChannelMerge {
  inputs 2
  operation plus
  name ChannelMerge1
  xpos 646
  ypos 65
 }
 Output {
  name Output
  xpos 646
  ypos 145
 }
end_group
Multiply {
 channels alpha
 value 5
 name Multiply2
 xpos -41
 ypos -675
}
Dot {
 name Dot5
 label "LAYER DENSITIES"
 note_font_size 20
 xpos -7
 ypos -624
}
Add {
 channels rgb
 value 0.048
 name Add1
 xpos -41
 ypos -536
}
Group {
 inputs 2
 name V_PtLight
 tile_color 0xc19139ff
 xpos -41
 ypos -478
 addUserKnob {20 VPtLight}
 addUserKnob {41 value l "Light Colour" T LIGHT_COL.value}
 addUserKnob {41 value_1 l "Scatter Colour" T SCATTER_COL.value}
 addUserKnob {7 intensity l Intensity}
 intensity 1.25
 addUserKnob {7 absorption l Absorption t "Amount of light absorbed by each voxel."}
 absorption 0.705
 addUserKnob {3 samples l Samples t "How many samples to take per pixel. higher values will give more accurate results at the cost of speed."}
 samples 64
 addUserKnob {26 ""}
 addUserKnob {41 operation T Merge.operation}
 addUserKnob {41 mix T Merge.mix}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_point.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_point.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_point.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_point.maxTileLines}
}
 Input {
  inputs 0
  name Inputlight
  label 1
  xpos 725
  ypos -4
  number 1
 }
 Input {
  inputs 0
  name Inputvoxels
  label 0
  xpos 603
  ypos -4
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 637
  ypos 74
 }
set N7837040 [stack 0]
 Clamp {
  channels alpha
  maximum inf
  name Clamp
  xpos 603
  ypos 116
 }
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 603
  ypos 158
  postage_stamp true
 }
 BlinkScript {
  kernelSourceFile bin/light/point.cpp
  KernelDescription "1 \"VPtLight\" iterate pixelWise ba9be73e015472e04940da642fd6d4b614fba9085b168cbbff6669efdee47694 2 \"voxels\" Read Random \"dst\" Write Point 8 \"bbox_min\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"bbox_max\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"resolution\" Int 3 AAAAAAAAAAAAAAAAAAAAAA== \"light\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"intensity\" Float 1 AACAPw== \"absorption\" Float 1 AAAAPw== \"samples\" Int 1 MgAAAA== \"transform_M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel VPtLight : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom> voxels;\n  Image<eWrite> dst;\n\n  param:\n    float3 bbox_min;\n    float3 bbox_max;\n    int3 resolution;\n    float3 light;\n    float intensity;\n    float absorption;\n    int samples;\n    float4x4 transform_M;\n\n  local:\n    float3 aabb\[2];\n    float3 VoxelSizeInv;\n    float3 _light;\n    int grid_width;\n    int _samples;\n\n  void define()\n  \{\n    defineParam(intensity, \"intensity\", 1.0f);\n    defineParam(absorption, \"absorption\", 0.5f);\n    defineParam(samples, \"samples\", 50);\n  \}\n\n  void init()\n  \{\n    aabb\[0] = bbox_min;\n    aabb\[1] = bbox_max;\n\n    for (int c = 0; c < 3; c++)\n      VoxelSizeInv\[c] = resolution\[c] / (bbox_max\[c] - bbox_min\[c]);\n\n    _light = multVectMatrix(light, transform_M.invert());\n\n    grid_width = voxels.bounds.width();\n    _samples = max(1, samples);\n  \}\n\n  float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  // Axis aligned bounding box intersection for GPU : Shortened for exit only\n  float intersection_exit_AABB(float3 origin, float3 inv_dir)\n  \{\n    //bool sign\[3] \{inv_dir.x < 0, inv_dir.y < 0, inv_dir.z < 0\};\n    float tmin, tmax, tymin, tymax, tzmin, tzmax;\n    bool sign = inv_dir.x < 0 ? 0 : 1;\n    tmax  = (aabb\[sign].x - origin.x) * inv_dir.x;\n    sign = inv_dir.y < 0 ? 0 : 1;\n    tymax = (aabb\[sign].y - origin.y) * inv_dir.y;\n    sign = inv_dir.z < 0 ? 0 : 1;\n    tzmax = (aabb\[sign].z - origin.z) * inv_dir.z;\n    tmax = min(min(tmax, tymax), tzmax);\n    return tmax;\n  \}\n\n  float voxelValue(int3 voxel)\n  \{\n    // Return Empty for values outside of grid\n    if (voxel.x < 0 || resolution.x <= voxel.x ||\n        voxel.y < 0 || resolution.y <= voxel.y ||\n        voxel.z < 0 || resolution.z <= voxel.z )\n      return 0;\n\n    int id = (voxel.y * resolution.x + voxel.x) * resolution.z + voxel.z;\n    int x = id % grid_width;\n    int y = id / grid_width;\n    return voxels(x, y)\[3]; // Just alpha (density)\n  \}\n\n  float Blend(float3 curpos)\n  \{\n    float3 weight, voxel_space;\n    int3 base_voxel, offset;\n    // Lower Bound of 8 adjacent voxels\n    for (int c = 0; c < 3; c++)\n    \{\n      voxel_space\[c] = curpos\[c] * VoxelSizeInv\[c];\n      base_voxel\[c] = int(floor(voxel_space\[c] - 0.5f));\n    \}\n\n    float result = 0;\n    for (int i = 0; i < 8; i++)\n    \{\n      // Weighted distance on each axis for each adjacent voxel\n      offset = int3(i / 4, (i / 2) % 2, i % 2);\n      weight.x = 1 - fabs(offset.x - (voxel_space.x - (base_voxel.x + 0.5f)));\n      weight.y = 1 - fabs(offset.y - (voxel_space.y - (base_voxel.y + 0.5f)));\n      weight.z = 1 - fabs(offset.z - (voxel_space.z - (base_voxel.z + 0.5f)));\n\n      result += voxelValue(base_voxel + offset) * weight.x * weight.y * weight.z;\n    \}\n\n    return result;\n  \}\n\n  void process(int2 pos)\n  \{\n    // Skip empty voxels\n    float4 v = voxels(pos.x, pos.y);\n    if (v.w <= 0)\n      return;\n\n    // Starting values\n    float3 voxel = float3(v.x, v.y, v.z); // Center of voxel\n    float3 dir = voxel - _light; // from light to voxel\n    float dist_to_light = length(dir);\n    dir /= dist_to_light;\n\n    // Fire ray towards light, get closest distance\n    float max_dist = min(dist_to_light, intersection_exit_AABB(voxel, -1.0f / dir));\n\n    // ========== Ray Marching ==========\n\n    // Maximum of 1000 samples per voxel\n    float deltaT, result = intensity, step = max(max_dist / _samples, 0.001f);\n    float3 curpos;\n\n    for (float dist = 0; dist <= max_dist; dist += step)\n    \{\n      curpos = voxel - dir * dist;\n      deltaT = exp(-absorption * Blend(curpos - bbox_min) * step);\n      result *= deltaT;\n\n      // End loop if Transmittance is near 0\n      if (result < 1e-6)\n      \tbreak;\n      //dist += (result < 1e-6) * max_dist;\n    \}\n\n    dst() = result;\n\n  \}\n\n\};"
  rebuild ""
  VPtLight_bbox_min {{"\[lindex \[metadata bbox] 0]"} {"\[lindex \[metadata bbox] 1]"} {"\[lindex \[metadata bbox] 2]"}}
  VPtLight_bbox_max {{"\[lindex \[metadata bbox] 3]"} {"\[lindex \[metadata bbox] 4]"} {"\[lindex \[metadata bbox] 5]"}}
  VPtLight_resolution {{"\[lindex \[metadata resolution] 0]"} {"\[lindex \[metadata resolution] 1]"} {"\[lindex \[metadata resolution] 2]"}}
  VPtLight_light {{input1.world_matrix.3} {input1.world_matrix.7} {input1.world_matrix.11}}
  VPtLight_intensity {{parent.intensity}}
  VPtLight_absorption {{parent.absorption}}
  VPtLight_samples {{parent.samples}}
  group_VPtLight_transform_M 1
  VPtLight_transform_M {
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 3]"}}
    }
  rebuild_finalise ""
  name BlinkScript_point
  selected true
  xpos 603
  ypos 278
 }
set N785c270 [stack 0]
 Dot {
  name Dot9
  note_font_size 20
  xpos 527
  ypos 288
 }
 Multiply {
  value {{1/intensity}}
  name Multiply2
  xpos 493
  ypos 330
 }
 Dot {
  name Dot7
  note_font_size 20
  xpos 527
  ypos 406
 }
set N788dae0 [stack 0]
push $N7837040
 Dot {
  name Dot3
  note_font_size 20
  xpos 307
  ypos 74
 }
 Multiply {
  channels rgb
  value 0
  name Multiply1
  xpos 273
  ypos 230
 }
 Dot {
  name Dot5
  note_font_size 20
  xpos 307
  ypos 288
 }
set N78a35d0 [stack 0]
 Add {
  value {1 0.915 0.775 1}
  value_panelDropped true
  name LIGHT_COL
  xpos 273
  ypos 331
 }
 Copy {
  inputs 2
  from0 rgba.alpha
  to0 rgba.alpha
  name Copy2
  xpos 273
  ypos 396
 }
 Dot {
  name Dot8
  note_font_size 20
  xpos 307
  ypos 537
 }
push $N788dae0
 Invert {
  channels alpha
  name Invert1
  xpos 493
  ypos 458
 }
push $N78a35d0
 Dot {
  name Dot6
  note_font_size 20
  xpos 417
  ypos 288
 }
 Add {
  value {0.165 0.32 0.535 0}
  value_panelDropped true
  name SCATTER_COL
  xpos 383
  ypos 331
 }
 Copy {
  inputs 2
  from0 rgba.alpha
  to0 rgba.alpha
  name Copy1
  xpos 383
  ypos 458
 }
 Merge2 {
  inputs 2
  operation xor
  name Merge1
  xpos 383
  ypos 533
 }
 Dot {
  name Dot10
  note_font_size 20
  xpos 417
  ypos 601
 }
push $N785c270
 Merge2 {
  inputs 2
  operation multiply
  name Merge2
  xpos 603
  ypos 597
 }
 Dot {
  name Dot2
  note_font_size 20
  xpos 637
  ypos 738
 }
push $N7837040
 Dot {
  name Dot4
  note_font_size 20
  xpos 759
  ypos 74
 }
 Merge2 {
  inputs 2
  operation plus
  Achannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name Merge
  xpos 725
  ypos 734
 }
 Output {
  name Output
  xpos 725
  ypos 793
 }
end_group
Group {
 inputs 2
 name V_EnvLight
 tile_color 0xc19139ff
 xpos -41
 ypos -405
 addUserKnob {20 VEnvLight}
 addUserKnob {6 luminance l "Luminance Based" t "Uses the luminance of the HDRI to light the image." +STARTLINE}
 addUserKnob {7 rotate l Rotate t "Rotates the spherical mapping" R 0 360}
 rotate 92
 addUserKnob {7 intensity l Intensity}
 intensity 0.79
 addUserKnob {7 absorption l Absorption t "Amount of light absorbed by each voxel."}
 absorption 0.585
 addUserKnob {3 range l Range t "Radius of area to blend"}
 range 2
 addUserKnob {3 samples l Samples t "How many samples to take per voxel. Higher values will give more accurate results at the cost of speed."}
 samples 64
 addUserKnob {26 ""}
 addUserKnob {41 operation T Merge.operation}
 addUserKnob {41 mix T Merge.mix}
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_environment.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_environment.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_environment.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_environment.maxTileLines}
}
 Input {
  inputs 0
  name Inputenv
  label 0
  xpos 1007
  ypos -84
  number 1
 }
 Input {
  inputs 0
  name Inputvoxels
  label 0
  xpos 1204
  ypos -348
 }
 Dot {
  name Dot1
  note_font_size 20
  xpos 1238
  ypos -288
 }
set N794c850 [stack 0]
 Clamp {
  channels alpha
  maximum inf
  name Clamp
  xpos 1204
  ypos -244
 }
 Shuffle {
  in2 voxels
  red red2
  green green2
  blue blue2
  name Shuffle1
  label "<font size = \"5\"> \[value in]"
  xpos 1204
  ypos -198
  postage_stamp true
 }
 BlinkScript {
  inputs 2
  kernelSourceFile bin/light/environment.cpp
  recompileCount 21
  ProgramGroup 1
  KernelDescription "2 \"VEnvLight\" iterate pixelWise c1d75786f9965f04a0d8275df3516fcbd715f02b109ab7dbf959a0768785adbb 3 \"voxels\" Read Random \"environment\" Read Random \"dst\" Write Point 9 \"bbox_min\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"bbox_max\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"resolution\" Int 3 AAAAAAAAAAAAAAAAAAAAAA== \"luminance_on\" Bool 1 AA== \"rotate\" Float 1 AAAAAA== \"intensity\" Float 1 AACAPw== \"absorption\" Float 1 AAAAPw== \"samples\" Int 1 MgAAAA== \"transform_M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 9 \"bbox_min\" 3 1 \"bbox_max\" 3 1 \"resolution\" 3 1 \"luminance_on\" 1 1 \"rotate\" 1 1 \"intensity\" 1 1 \"absorption\" 1 1 \"samples\" 1 1 \"transform_M\" 16 1 6 \"aabb\" Float 3 2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"VoxelSizeInv\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"_absorption\" Float 1 1 AAAAAA== \"grid_width\" Int 1 1 AAAAAA== \"rad2deg\" Float 1 1 AAAAAA== \"_samples\" Int 1 1 AAAAAA=="
  kernelSource "kernel VEnvLight : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom> voxels;\n  Image<eRead, eAccessRandom> environment;\n  Image<eWrite> dst;\n\n  param:\n    float3 bbox_min;\n    float3 bbox_max;\n    int3 resolution;\n    bool luminance_on;\n    float rotate;\n    float intensity;\n    float absorption;\n    int samples;\n    float4x4 transform_M;\n\n  local:\n    float3 aabb\[2];\n    float3 VoxelSizeInv;\n    float _absorption;\n    int grid_width;\n    float rad2deg;\n    int _samples;\n\n  void define()\n  \{\n    defineParam(intensity, \"intensity\", 1.0f);\n    defineParam(absorption, \"absorption\", 0.5f);                   // Absorption? Rate of Decay\n    defineParam(samples, \"samples\", 50);\n  \}\n\n  void init()\n  \{\n    aabb\[0] = bbox_min;\n    aabb\[1] = bbox_max;\n    grid_width = voxels.bounds.width();\n\n    for (int c = 0; c < 3; c++)\n      VoxelSizeInv\[c] = resolution\[c] / (bbox_max\[c] - bbox_min\[c]);\n\n    _absorption = 1 / (1 - absorption);\n    rad2deg = 180.0f / PI;\n    _samples = max(1, samples);\n  \}\n\n  float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  // Axis aligned bounding box intersection for GPU : Shortened for exit only\n  float intersection_exit_AABB(float3 origin, float3 inv_dir)\n  \{\n    //bool sign\[3] \{inv_dir.x < 0, inv_dir.y < 0, inv_dir.z < 0\};\n    float tmin, tmax, tymin, tymax, tzmin, tzmax;\n    bool sign = inv_dir.x < 0 ? 0 : 1;\n    tmax  = (aabb\[sign].x - origin.x) * inv_dir.x;\n    sign = inv_dir.y < 0 ? 0 : 1;\n    tymax = (aabb\[sign].y - origin.y) * inv_dir.y;\n    sign = inv_dir.z < 0 ? 0 : 1;\n    tzmax = (aabb\[sign].z - origin.z) * inv_dir.z;\n    tmax = min(min(tmax, tymax), tzmax);\n    return tmax;\n  \}\n\n  float voxelValue(int3 voxel)\n  \{\n    // Return Empty for values outside of grid\n    if (voxel.x < 0 || resolution.x <= voxel.x ||\n        voxel.y < 0 || resolution.y <= voxel.y ||\n        voxel.z < 0 || resolution.z <= voxel.z )\n      return 0;\n\n    int id = (voxel.y * resolution.x + voxel.x) * resolution.z + voxel.z;\n    int x = id % grid_width;\n    int y = id / grid_width;\n    return voxels(x, y)\[3]; // Just alpha (density)\n  \}\n\n  float Blend(float3 curpos)\n  \{\n    float3 weight, voxel_space;\n    int3 base_voxel, offset;\n    // Lower Bound of 8 adjacent voxels\n    for (int c = 0; c < 3; c++)\n    \{\n      voxel_space\[c] = curpos\[c] * VoxelSizeInv\[c];\n      base_voxel\[c] = int(floor(voxel_space\[c] - 0.5f));\n    \}\n\n    float result = 0;\n    for (int i = 0; i < 8; i++)\n    \{\n      // Weighted distance on each axis for each adjacent voxel\n      offset = int3(i / 4, (i / 2) % 2, i % 2);\n      weight.x = 1 - fabs(offset.x - (voxel_space.x - (base_voxel.x + 0.5f)));\n      weight.y = 1 - fabs(offset.y - (voxel_space.y - (base_voxel.y + 0.5f)));\n      weight.z = 1 - fabs(offset.z - (voxel_space.z - (base_voxel.z + 0.5f)));\n\n      result += voxelValue(base_voxel + offset) * weight.x * weight.y * weight.z;\n    \}\n\n    return result;\n  \}\n\n  void process(int2 pos)\n  \{\n    // Skip empty voxels\n    float4 v = voxels(pos.x, pos.y);\n    if (v.w <= 0)\n      return;\n\n\n    // ========== AMBIENT LIGHT ==========\n\n    // Fire a ray from outer sphere to voxel, accumulate fog\n\n    // Starting values\n    float3 voxel = float3(v.x, v.y, v.z); // Center of voxel\n\n    int3 voxel_i;\n    for (int c = 0; c < 3; c++)\n      voxel_i\[c] = (voxel\[c] - bbox_min\[c]) * VoxelSizeInv\[c];\n\n    float3 normal = float3(\n      voxelValue(voxel_i - int3(1,0,0)) - voxelValue(voxel_i + int3(1,0,0)),\n      voxelValue(voxel_i - int3(0,1,0)) - voxelValue(voxel_i + int3(0,1,0)),\n      voxelValue(voxel_i - int3(0,0,1)) - voxelValue(voxel_i + int3(0,0,1))\n      );\n\n    float3 dir = -normalize(normal);\n    // Skip directionless voxels\n    if (dir.x == 0 && dir.y == 0 && dir.z == 0) return;\n\n    float3 dir_inv = 1.0f / dir;\n\n    // Convert direction to latlong coordinates\n    float3 env_dir = normalize(multVectMatrix(dir, transform_M));\n    float x = (fmod((rad2deg * atan2(env_dir.z, env_dir.x) + rotate), 360.0f) / 360.0f + 0.5f) * environment.bounds.width();\n    float y = ((rad2deg * acos(env_dir.y)) / 180.0f) * environment.bounds.height();\n\n    float4 colour = environment(x, y);\n    float luminance = (colour.x * 0.3f + colour.y * 0.59f + colour.z * 0.11f) * intensity;\n\n    // Move starting point to whatever's closest: intersection / light\n    float max_dist = intersection_exit_AABB(voxel, -dir_inv);\n\n    // ========== Ray Marching ==========\n\n    // Maximum of 1000 samples per voxel\n    float result = luminance * luminance_on + intensity * (1 - luminance_on);\n    float deltaT = 1, step = max(max_dist / _samples, 0.001f);\n    float3 curpos;\n\n    for (float dist = 0; dist <= max_dist; dist += step)\n    \{\n      curpos = voxel - dir * dist;\n      deltaT = exp(-absorption * Blend(curpos - bbox_min) * step);\n      result *= deltaT;\n\n      // End loop if Transmittance is near 0\n      if (result < 1e-6)\n        break;\n      //dist += (result < 1e-6) * max_dist;\n    \}\n\n    dst() = result * environment(x, y);\n    dst(3) = v.w;\n    \n  \}\n\n\};"
  rebuild ""
  VEnvLight_bbox_min {{"\[lindex \[metadata bbox] 0]"} {"\[lindex \[metadata bbox] 1]"} {"\[lindex \[metadata bbox] 2]"}}
  VEnvLight_bbox_max {{"\[lindex \[metadata bbox] 3]"} {"\[lindex \[metadata bbox] 4]"} {"\[lindex \[metadata bbox] 5]"}}
  VEnvLight_resolution {{"\[lindex \[metadata resolution] 0]"} {"\[lindex \[metadata resolution] 1]"} {"\[lindex \[metadata resolution] 2]"}}
  VEnvLight_luminance_on {{parent.luminance}}
  VEnvLight_rotate {{parent.rotate}}
  VEnvLight_intensity {{intensity}}
  VEnvLight_absorption {{absorption}}
  VEnvLight_samples {{samples}}
  VEnvLight_transform_M {
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 3]"}}
    }
  rebuild_finalise ""
  name BlinkScript_environment
  xpos 1204
  ypos -84
 }
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name Crop
  xpos 1204
  ypos -46
 }
 Group {
  name V_Average1
  knobChanged "\nif nuke.thisKnob().name() == \"weight_channels\":\n    knob = nuke.thisNode().knob(\"weight\")\n    value = nuke.thisKnob().getValue()\n    if value < 3:\n        knob.setFlag(0x00040000)\n    else:\n        knob.clearFlag(0x00040000)\n"
  tile_color 0xc17a39ff
  xpos 1204
  ypos -20
  addUserKnob {20 vaverage l "Voxel Average"}
  addUserKnob {3 range l Range t "The radius of the area to blend.\nWill only average voxels with positive density."}
  range {{parent.range}}
  addUserKnob {4 weight_channels l "         Channels" t "Channels to be blended together. Custom can be used to set individual weights per channel" M {rgb rgba alpha custom "" "" "" ""}}
  addUserKnob {19 weight l Weight t "Individual weights (0 to 1) to blend per channel" +HIDDEN}
  weight {0.5 0.5 0.5 0}
  addUserKnob {6 weight_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 }
  Input {
   inputs 0
   name Input
   xpos 362
   ypos -626
  }
  Dot {
   name Dot13
   note_font_size 20
   xpos 396
   ypos -557
  }
set N79b4b70 [stack 0]
  Shuffle {
   in voxels
   in2 rgba
   alpha alpha2
   name Shuffle2
   label "<font size = \"5\"> \[value in]"
   xpos 533
   ypos -597
   postage_stamp true
  }
  Dot {
   name Dot14
   note_font_size 20
   xpos 567
   ypos -436
  }
push $N79b4b70
  BlinkScript {
   inputs 2
   kernelSourceFile C:/Users/mshaw/Documents/Tests/Blink/Cloud_Gen_03/Scripts/WORKING/VoxelAverage_transform_002.cpp
   ProgramGroup 1
   KernelDescription "1 \"VoxelAverage\" iterate pixelWise 6c113d5dedc64ba6e56941b86052ff305117ae1399471bb6912c3cbe74066441 3 \"colour\" Read Random \"voxels\" Read Random \"dst\" Write Point 5 \"weight\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"bbox_min\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"bbox_max\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"resolution\" Int 3 AAAAAAAAAAAAAAAAAAAAAA== \"range\" Int 1 AAAAAA=="
   kernelSource "kernel VoxelAverage : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom> colour;\n  Image<eRead, eAccessRandom> voxels;\n  Image<eWrite> dst;\n\n  param:\n    float4 weight;\n    float3 bbox_min;\n    float3 bbox_max;\n    int3 resolution;\n    int range;\n\n  local:\n    float4 _weight;\n    float3 VoxelSizeInv;\n    int grid_width;\n    float max_length;\n\n  void init()\n  \{\n    for (int c = 0; c < 3; c++)\n    \{\n      VoxelSizeInv\[c] = resolution\[c] / (bbox_max\[c] - bbox_min\[c]);\n      _weight\[c] = clamp(weight\[c], 0.0f, 1.0f);\n    \}\n    _weight.w = clamp(weight.w, 0.0f, 1.0f);\n    grid_width = voxels.bounds.width();\n  \}\n\n  float4 voxelValue(int3 voxel)\n  \{\n    int id = (voxel.y * resolution.x + voxel.x) * resolution.z + voxel.z;\n    int x = id % grid_width;\n    int y = id / grid_width;\n    return colour(x, y);\n  \}\n\n  void process(int2 pos)\n  \{\n    float4 current = voxels(pos.x, pos.y);\n\n    int3 voxel;\n    for (int c = 0; c < 3; c++)\n      voxel\[c] = int((current\[c] - bbox_min\[c]) * VoxelSizeInv\[c]);\n\n    float4 value, result = 0;\n    int total = 0;\n\n    // Maximum value within specified range\n    for (int i = max(voxel.x - range, 0); i <= min(voxel.x + range, resolution.x - 1); i++)\n      for (int j = max(voxel.y - range, 0); j <= min(voxel.y + range, resolution.y - 1); j++)\n        for (int k = max(voxel.z - range, 0); k <= min(voxel.z + range, resolution.z - 1); k++)\n        \{\n          value = voxelValue(int3(i, j, k));\n          total += (value.w > 0);\n          result += value * (value.w > 0);\n        \}\n    \n    current = voxelValue(voxel);\n    if (total < 1)\n      dst() = current;\n    else\n      for (int c = 0; c < 4; c++)\n        dst(c) = (result\[c] / total - current\[c]) * _weight\[c] + current\[c];\n  \}\n\};"
   rebuild ""
   VoxelAverage_weight {{"weight_channels < 2 ? 1 : (weight_channels == 2 ? 0 : weight)"} {"weight_channels < 2 ? 1 : (weight_channels == 2 ? 0 : weight)"} {"weight_channels < 2 ? 1 : (weight_channels == 2 ? 0 : weight)"} {"weight_channels == 0 ? 0 : (weight_channels == 1 || weight_channels == 2 ? 1 : weight)"}}
   VoxelAverage_bbox_min {{"\[lindex \[metadata bbox] 0]"} {"\[lindex \[metadata bbox] 1]"} {"\[lindex \[metadata bbox] 2]"}}
   VoxelAverage_bbox_max {{"\[lindex \[metadata bbox] 3]"} {"\[lindex \[metadata bbox] 4]"} {"\[lindex \[metadata bbox] 5]"}}
   VoxelAverage_resolution {{"\[lindex \[metadata resolution] 0]"} {"\[lindex \[metadata resolution] 1]"} {"\[lindex \[metadata resolution] 2]"}}
   VoxelAverage_range {{parent.range}}
   rebuild_finalise ""
   name BlinkScript3
   selected true
   xpos 362
   ypos -446
  }
  Output {
   name Output1
   xpos 362
   ypos -346
  }
 end_group
 Dot {
  name Dot3
  note_font_size 20
  xpos 1238
  ypos 51
 }
push $N794c850
 Dot {
  name Dot2
  note_font_size 20
  xpos 1354
  ypos -288
 }
 Merge2 {
  inputs 2
  operation plus
  Achannels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name Merge
  xpos 1320
  ypos 47
 }
 Output {
  name Output
  xpos 1320
  ypos 108
 }
end_group
Dot {
 name Dot7
 label LIGHTING
 note_font_size 20
 xpos -7
 ypos -359
}
FrameHold {
 first_frame 125
 name FrameHold1
 xpos -41
 ypos -262
}
Dot {
 name Dot8
 label "IF LIGHT AND CLOUD AREN'T MOVING,\nCAN BE HELD FOR QUICK RENDERING"
 note_font_size 20
 xpos -7
 ypos -213
}
Group {
 inputs 2
 name V_Render
 tile_color 0xbdb039ff
 xpos -41
 ypos -127
 addUserKnob {20 VRender}
 addUserKnob {41 format l Format T FORMAT.format}
 addUserKnob {7 density l Density t "The amount of light absorbed by each voxel. Lower to get a thinner result."}
 density 1
 addUserKnob {3 samples l Samples t "Number of samples per pixel. Higher values will increase accuracy at the cost of speed."}
 samples 128
 addUserKnob {20 graphics l GPU}
 addUserKnob {41 "Local GPU: " T BlinkScript_render.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript_render.useGPUIfAvailable}
 addUserKnob {41 maxGPUMemory l "Percentage of GPU memory to use" T BlinkScript_render.maxGPUMemory}
 addUserKnob {41 maxTileLines l "Percentage of image height per tile" T BlinkScript_render.maxTileLines}
}
 Input {
  inputs 0
  name Inputcam
  label 1
  xpos 655
  ypos -128
  number 1
 }
 Reformat {
  inputs 0
  name FORMAT
  xpos 384
  ypos 90
 }
 Input {
  inputs 0
  name Input
  label 0
  xpos 535
  ypos -127
 }
 Clamp {
  maximum inf
  name Clamp1
  xpos 535
  ypos -33
 }
 BlinkScript {
  kernelSourceFile bin/render/render.cpp
  KernelDescription "1 \"VRender\" iterate pixelWise a604b5c97cabd396fed0640f0dca39e8f373a0616f5fa0bd8c103d2f33ab5115 2 \"voxels\" Read Random \"dst\" Write Point 11 \"Resolution\" Int 3 CgAAAAoAAAAKAAAAAAAAAA== \"bbox_min\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"bbox_max\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"density\" Float 1 AACAPw== \"samples\" Int 1 MgAAAA== \"Width\" Float 1 AAC0RA== \"Height\" Float 1 AIBKRA== \"Focal\" Float 1 AADwQQ== \"Haperture\" Float 1 ppvEQQ== \"cam_M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"transform_M\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
  kernelSource "kernel VRender : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessRandom> voxels;\n  Image<eWrite> dst;\n\n  param:\n    int3 resolution;\n    float3 bbox_min;\n    float3 bbox_max;\n    float density;\n    int samples;\n    // Camera Parameters\n    float width;\n    float height;\n    float focal;\n    float haperture;\n    float4x4 cam_M;\n    float4x4 transform_M;\n\n  local:\n    float3 aabb\[2];\n    float3 voxelHalfSize;\n    float3 VoxelSizeInv;\n    int grid_width;\n    int _samples;\n    // Camera Parameters\n    float ratio;\n    float3 camera;\n    float3 up;\n    float3 right;\n    float3 forward;\n\n  void define()\n  \{\n    defineParam(resolution, \"Resolution\", int3(10,10,10));\n    defineParam(density, \"density\", 1.0f);\n    defineParam(samples, \"samples\", 50);\n    // Camera Parameters\n    defineParam(width, \"Width\", 1440.0f);\n    defineParam(height, \"Height\", 810.0f);\n    defineParam(focal, \"Focal\", 30.0f);\n    defineParam(haperture, \"Haperture\", 24.576f);\n  \}\n\n  void init()\n  \{\n    aabb\[0] = bbox_min;\n    aabb\[1] = bbox_max;\n    for (int c = 0; c < 3; c++)\n      VoxelSizeInv\[c] = resolution\[c] / (bbox_max\[c] - bbox_min\[c]);\n    voxelHalfSize = 0.5f / VoxelSizeInv;\n    grid_width = voxels.bounds.width();\n    _samples = max(1, samples);\n\n    float4x4 camM = transform_M.invert() * cam_M;\n\n    // Camera Parameters\n    ratio   = focal / haperture; \n    camera  = float3(camM\[0]\[3], camM\[1]\[3], camM\[2]\[3]);\n    up      = normalize(multVectMatrix(float3(0.0f, 1.0f, 0.0f), camM) - camera) * (height / width);\n    right   = normalize(multVectMatrix(float3(1.0f, 0.0f, 0.0f), camM) - camera);\n    forward = normalize(multVectMatrix(float3(0.0f, 0.0f, -1.0f), camM) - camera); \n  \}\n\n  float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 voxelValue(int3 voxel)\n  \{\n    // Return Empty for values outside of grid\n    if (voxel.x < 0 || resolution.x <= voxel.x ||\n        voxel.y < 0 || resolution.y <= voxel.y ||\n        voxel.z < 0 || resolution.z <= voxel.z )\n      return 0;\n\n    int id = (voxel.y * resolution.x + voxel.x) * resolution.z + voxel.z;\n    int x = id % grid_width;\n    int y = id / grid_width;\n\n    return voxels(x, y);\n  \}\n  \n\n  float4 Blend(float3 curpos)\n  \{\n    float3 weight, voxel_space;\n    int3 base_voxel, offset;\n    // Lower Bound of 8 adjacent voxels\n    for (int c = 0; c < 3; c++)\n    \{\n      voxel_space\[c] = curpos\[c] * VoxelSizeInv\[c];\n      base_voxel\[c] = int(floor(voxel_space\[c] - 0.5f));\n    \}\n\n    float4 result = 0;\n    for (int i = 0; i < 8; i++)\n    \{\n      // Weighted distance on each axis for each adjacent voxel\n      offset = int3(i / 4, (i / 2) % 2, i % 2);\n      weight.x = 1 - fabs(offset.x - (voxel_space.x - (base_voxel.x + 0.5f)));\n      weight.y = 1 - fabs(offset.y - (voxel_space.y - (base_voxel.y + 0.5f)));\n      weight.z = 1 - fabs(offset.z - (voxel_space.z - (base_voxel.z + 0.5f)));\n\n      result += voxelValue(base_voxel + offset) * weight.x * weight.y * weight.z;\n    \}\n\n    return result;\n  \}\n\n\n  float2 intersection_AABB(float3 origin, float3 inv_dir)\n  \{\n    // Axis aligned bounding box intersection for GPU\n    // aabb = min_corner, max_corner (eg, (0,0,0), (1,1,1))\n    // ray =  origin, direction, inv_dir (1/dir), sign (x < 0 ? 1 : 0)\n    float tmin, tmax, tymin, tymax, tzmin, tzmax;\n    bool sign = inv_dir.x < 0 ? 0 : 1;\n    tmin  = (aabb\[1 - sign].x - origin.x) * inv_dir.x;\n    tmax  = (aabb\[sign].x - origin.x) * inv_dir.x;\n    sign = inv_dir.y < 0 ? 0 : 1;\n    tymin = (aabb\[1 - sign].y - origin.y) * inv_dir.y;\n    tymax = (aabb\[sign].y - origin.y) * inv_dir.y;\n    sign = inv_dir.z < 0 ? 0 : 1;\n    tzmin = (aabb\[1 - sign].z - origin.z) * inv_dir.z;\n    tzmax = (aabb\[sign].z - origin.z) * inv_dir.z;\n    tmin = max(max(tmin, tymin), tzmin);\n    tmax = min(min(tmax, tymax), tzmax);\n    return float2(max(tmin, 0.0f), tmax);\n  \}\n\n\n  void process(int2 pos)\n  \{\n    // Calculating the eye vector\n    float u = pos.x / width - 0.5f;\n    float v = pos.y / height - 0.5f;\n\n    // Ray direction\n    float3 dir = normalize(forward * ratio + right * u + up * v);\n\n    // ========== Box Intersection (Entry and Exit) ==========\n\n    float2 tMinMax = intersection_AABB(camera, 1.0f / dir);\n\n    bool hit = (tMinMax.x < tMinMax.y);// && (tMinMax.x >= near_clip_plane) && (tMinMax.y <= far_clip_plane)\n    if (!hit)\n    \{\n      dst() = 0;\n      return;\n    \}\n\n    // Maximum of 1000 samples per voxel\n    float max_dist = tMinMax.y - tMinMax.x;\n    float deltaT, T = 1, step = max(max_dist / _samples, 0.001f);\n    float3 curpos;\n    float4 result = 0, colour;\n\n    for (float dist = tMinMax.x; dist <= tMinMax.y; dist += step)\n    \{\n      curpos = camera + dir * dist;\n      colour = Blend(curpos - bbox_min);\n      deltaT = exp(-density * colour.w * step);\n      T *= deltaT;\n      result += (1 - deltaT) * colour * T;\n\n      // End loop if Transmittance is near 0\n      if (T < 1e-6)\n        break;\n    \}\n\n    dst() = result;\n    dst(3) = 1 - T;\n  \}\n\};"
  rebuild ""
  VRender_Resolution {{"\[lindex \[metadata resolution] 0]"} {"\[lindex \[metadata resolution] 1]"} {"\[lindex \[metadata resolution] 2]"}}
  VRender_bbox_min {{"\[lindex \[metadata bbox] 0]"} {"\[lindex \[metadata bbox] 1]"} {"\[lindex \[metadata bbox] 2]"}}
  VRender_bbox_max {{"\[lindex \[metadata bbox] 3]"} {"\[lindex \[metadata bbox] 4]"} {"\[lindex \[metadata bbox] 5]"}}
  VRender_density {{parent.density}}
  VRender_samples {{parent.samples}}
  VRender_Width {{FORMAT.width}}
  VRender_Height {{FORMAT.height}}
  VRender_Focal {{group.input1.focal}}
  VRender_Haperture {{group.input1.haperture}}
  group_VRender_cam_M 1
  VRender_cam_M {
      {{group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix}}
      {{group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix}}
      {{group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix}}
      {{group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix} {group.input1.world_matrix}}
    }
  group_VRender_transform_M 1
  VRender_transform_M {
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 0] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 1] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 2] 3]"}}
      {{"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 0]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 1]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 2]"} {"\[lindex \[lindex \[metadata vTransformMatrix frame] 3] 3]"}}
    }
  rebuild_finalise ""
  name BlinkScript_render
  xpos 535
  ypos 84
 }
 Output {
  name Output
  xpos 535
  ypos 222
 }
end_group
Dot {
 name Dot9
 label RENDER
 note_font_size 20
 xpos -7
 ypos -58
}
push $N5ff69b0
Dot {
 name Dot6
 note_font_size 20
 xpos -260
 ypos 13
}
Merge2 {
 inputs 2
 name Merge1
 xpos -41
 ypos 9
}
Dither {
 amount 0.0095
 name Dither1
 xpos -41
 ypos 35
}
Viewer {
 frame_range 1-360
 name Viewer1
 xpos -41
 ypos 242
}
